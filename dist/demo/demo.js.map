{"version":3,"sources":["app/demo/debugGUI.js","app/demo/main.js","app/demo/sprites/generic_enemy.js","app/demo/states/Boot.js","app/demo/states/Game.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA3DA;AAAA;ACAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAzCA;AAAA;ACAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAtFA;AAAA;ACAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAzDA;AAAA;ACAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAjSA;AAAA","file":"dist/demo/demo.js","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar debugGUI = function (_dat$GUI) {\n    _inherits(debugGUI, _dat$GUI);\n\n    function debugGUI() {\n        _classCallCheck(this, debugGUI);\n\n        var _this = _possibleConstructorReturn(this, (debugGUI.__proto__ || Object.getPrototypeOf(debugGUI)).call(this));\n\n        _this.value = 0;\n        _this.listen = 0;\n\n        return _this;\n    }\n\n    _createClass(debugGUI, [{\n        key: 'setupGUI',\n        value: function setupGUI(that) {\n\n            this.heroFolder = this.addFolder('Hero');\n            this.worldFolder = this.addFolder('World');\n            this.debugFolder = this.addFolder('Debug');\n\n            this.heroFolder.add(that.game.hero.body, 'strength', 0, 10).step(1).name('Strength');\n            this.heroFolder.add(that.game.hero.body, 'strength', 0, 10).step(1).name('MaxCue');\n            this.heroFolder.add(that.game.hero.body, 'struggle', 0, 10).step(1).name('Struggle');\n            this.heroFolder.add(that.game.hero.body, 'baseVelocity', 1, 480).step(1).name('Velocity');\n            this.heroFolder.add(that.game.hero, 'debugger').name('Debug body');\n            this.heroFolder.add(that.game.hero.body, 'collidable').name('Collidable');\n            this.heroFolder.add(that.game.hero.body, 'activeSteps').name('Steps').listen();\n            this.heroFolder.open();\n            this.debugFolder.add(that.debugGfx.grid, 'active').name('Grid');\n            this.debugFolder.add(that.debugGfx.collision, 'active').name('Collision');\n            this.debugFolder.add(that.debugGfx.path, 'active').name('Path');\n            this.debugFolder.add(that.debugGfx.pathCollision, 'active').name('Path collision');\n\n            //    this.worldFolder.add(that, 'renderGrid').name('Render grid');\n            this.worldFolder.add(that.physics, 'turnbased').name('Turn based');\n            this.worldFolder.open();\n        }\n    }]);\n\n    return debugGUI;\n}(dat.GUI);\n\nexports.default = debugGUI;\n","'use strict';\n\nvar _Boot = require('./states/Boot');\n\nvar _Boot2 = _interopRequireDefault(_Boot);\n\nvar _Game = require('./states/Game');\n\nvar _Game2 = _interopRequireDefault(_Game);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nwindow.EasyStar = require('easystarjs');\n\nvar Game = function (_Phaser$Game) {\n  _inherits(Game, _Phaser$Game);\n\n  function Game() {\n    _classCallCheck(this, Game);\n\n    var width = document.documentElement.clientWidth > 400 ? 400 : document.documentElement.clientWidth;\n    var height = Math.round(0.6 * width);\n\n    var _this = _possibleConstructorReturn(this, (Game.__proto__ || Object.getPrototypeOf(Game)).call(this, width, height, Phaser.CANVAS, 'content', null, false, false));\n\n    _this.state.add('Boot', _Boot2.default, false);\n    _this.state.add('Game', _Game2.default, false);\n    _this.state.start('Boot');\n    return _this;\n  }\n\n  return Game;\n}(Phaser.Game);\n\nwindow.game = new Game();\n","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar GenericEnemy = function (_Phaser$Sprite) {\n  _inherits(GenericEnemy, _Phaser$Sprite);\n\n  function GenericEnemy(_ref) {\n    var game = _ref.game,\n        x = _ref.x,\n        y = _ref.y,\n        family = _ref.family,\n        id = _ref.id;\n\n    _classCallCheck(this, GenericEnemy);\n\n    var _this = _possibleConstructorReturn(this, (GenericEnemy.__proto__ || Object.getPrototypeOf(GenericEnemy)).call(this, game, x, y, \"sprites\"));\n\n    _this.animations.add(\"animation\", [family + \"/\" + family + 0 + \"-\" + id, family + \"/\" + family + 1 + \"-\" + id], 5, true);\n    _this.game = game;\n    _this.exists = true;\n    _this.reset(x, y);\n    _this.play(\"animation\");\n    _this.game.physics.gridPhysics.enable(_this);\n    _this.body.immovable = true;\n    _this.body.collideWorldBounds = true;\n    _this.game.add.existing(_this);\n    _this.turnSteps = _this.body.activeSteps + 1;\n    return _this;\n  }\n\n  _createClass(GenericEnemy, [{\n    key: \"update\",\n    value: function update() {\n      if (!this.body.myTurn && this.body.physics.turnbased) {\n        return;\n      }\n      if (this.turnSteps == 1) {\n        this.turnSteps = 0;\n        this.body.physics.nextTurn(this.body);\n      }\n      if ((this.body.velocity.x !== 0 || this.body.velocity.y !== 0) && Math.random() < 0.1) {\n        return;\n      }\n      if (this.body.physics.turnbased) {\n        this.body.baseVelocity = 75;\n      } else {\n        this.body.baseVelocity = 20;\n      }\n      var velx = 0,\n          vely = 0;\n      switch (Math.round(Math.random() * 3)) {\n        case 0:\n          velx = this.body.baseVelocity;\n          break;\n        case 1:\n          velx = -this.body.baseVelocity;\n          break;\n        case 2:\n          vely = this.body.baseVelocity;\n          break;\n        case 3:\n          vely = -this.body.baseVelocity;\n          break;\n      }\n      this.body.setVelocity(velx, vely);\n      if (this.body.physics.turnbased) {\n        this.turnSteps++;\n      }\n    }\n  }]);\n\n  return GenericEnemy;\n}(Phaser.Sprite);\n\nexports.default = GenericEnemy;\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _Game = require('./Game');\n\nvar _Game2 = _interopRequireDefault(_Game);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar Preload = function (_Phaser$State) {\n    _inherits(Preload, _Phaser$State);\n\n    function Preload() {\n        _classCallCheck(this, Preload);\n\n        return _possibleConstructorReturn(this, (Preload.__proto__ || Object.getPrototypeOf(Preload)).apply(this, arguments));\n    }\n\n    _createClass(Preload, [{\n        key: 'preload',\n        value: function preload() {\n            this.game.load.image('enemy', './assets/images/enemy.png');\n            this.game.load.image('basictiles', './assets/images/basictiles.png');\n            this.game.load.tilemap('map', './assets/maps/demo.json', null, Phaser.Tilemap.TILED_JSON);\n            this.game.load.atlas('sprites', 'assets/spriteatlas/sprites.png', 'assets/spriteatlas/sprites.json', Phaser.Loader.TEXTURE_ATLAS_JSON_ARRAY);\n        }\n    }, {\n        key: 'create',\n        value: function create() {\n            this.game.smoothed = false;\n            this.game.scale.scaleMode = Phaser.ScaleManager.SHOW_ALL;\n            this.game.scale.setMinMax(400, 240, 400 * 3, 240 * 3);\n            this.game.load.onLoadComplete.add(this.loadComplete, this);\n            this.loadComplete();\n        }\n    }, {\n        key: 'loadComplete',\n        value: function loadComplete() {\n            this.state.start('Game');\n        }\n    }]);\n\n    return Preload;\n}(Phaser.State);\n\nexports.default = Preload;\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _gridPhysics = require('../../plugin/gridPhysics/gridPhysics');\n\nvar _gridPhysics2 = _interopRequireDefault(_gridPhysics);\n\nvar _generic_enemy = require('../sprites/generic_enemy');\n\nvar _generic_enemy2 = _interopRequireDefault(_generic_enemy);\n\nvar _debugGUI = require('../debugGUI');\n\nvar _debugGUI2 = _interopRequireDefault(_debugGUI);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar GameState = function (_Phaser$State) {\n    _inherits(GameState, _Phaser$State);\n\n    function GameState(game) {\n        _classCallCheck(this, GameState);\n\n        var _this = _possibleConstructorReturn(this, (GameState.__proto__ || Object.getPrototypeOf(GameState)).call(this, game));\n\n        _this.game = game;\n        return _this;\n    }\n\n    _createClass(GameState, [{\n        key: 'create',\n        value: function create() {\n            var game = this.game;\n            window.game = game;\n\n            game.plugins.add(new _gridPhysics2.default(this.game));\n            game.physics.gridPhysics.gridSize.set(8);\n            this.debugGfx = game.physics.gridPhysics.debugGfx;\n            this.physics = game.physics.gridPhysics;\n\n            game.map = game.add.tilemap('map', 16, 16);\n            var map = game.map;\n            this.map = map; // wierd: game.map, map and this.map. FIX\n\n            map.addTilesetImage('basictiles');\n            var layer = map.createLayer(\"ground\");\n            layer = map.createLayer(\"onGround\");\n            game.physics.gridPhysics.enable(layer);\n\n            for (var y = 0; y < layer.layer.data.length; y++) {\n                for (var x = 0; x < layer.layer.data[y].length; x++) {\n                    var tile = layer.layer.data[y][x];\n                    if (tile.index === -1) {\n                        continue;\n                    }\n                    var _iteratorNormalCompletion = true;\n                    var _didIteratorError = false;\n                    var _iteratorError = undefined;\n\n                    try {\n                        for (var _iterator = Object.keys(tile.properties)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                            var _property = _step.value;\n\n                            if (tile.hasOwnProperty(_property) || _property.indexOf(\"blocked\") === 0) {\n                                if (_property.indexOf(\"blocked\") > -1) {\n                                    console.log(\"blocked\" + _property);\n                                }\n\n                                tile[_property] = tile.properties[_property];\n                            }\n                        }\n                    } catch (err) {\n                        _didIteratorError = true;\n                        _iteratorError = err;\n                    } finally {\n                        try {\n                            if (!_iteratorNormalCompletion && _iterator.return) {\n                                _iterator.return();\n                            }\n                        } finally {\n                            if (_didIteratorError) {\n                                throw _iteratorError;\n                            }\n                        }\n                    }\n\n                    if (tile.properties.collide) {\n                        var _arr = [\"collideUp\", \"collideRight\", \"collideDown\", \"collideLeft\"];\n\n                        for (var _i = 0; _i < _arr.length; _i++) {\n                            var property = _arr[_i];\n                            tile[property] = true;\n                        }\n                    }\n                }\n            }\n            layer.updateBlocked();\n\n            layer.resizeWorld();\n\n            var _iteratorNormalCompletion2 = true;\n            var _didIteratorError2 = false;\n            var _iteratorError2 = undefined;\n\n            try {\n                for (var _iterator2 = this.map.objects.objects[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n                    var crateObj = _step2.value;\n\n\n                    var anim = \"box\";\n                    if (crateObj.properties && crateObj.properties.box) {\n                        anim += crateObj.properties.box;\n                    }\n\n                    var crate = game.add.sprite(crateObj.x, crateObj.y - 16, 'sprites');\n                    crate.animations.add(\"box\", [anim], 5, false);\n                    crate.play(\"box\");\n                    if (crateObj.properties && crateObj.properties.scale) {\n                        crate.width = 16 * crateObj.properties.scale;\n                        crate.height = 16 * crateObj.properties.scale;\n                    } else {\n                        crate.width = 16;\n                        crate.height = 16;\n                    }\n\n                    crate.smoothed = false;\n                    game.physics.gridPhysics.enable(crate);\n                    crate.body.collideWorldBounds = true;\n\n                    if (crateObj.properties && crateObj.properties.mass) {\n                        crate.body.mass = crateObj.properties.mass;\n                    }\n                }\n            } catch (err) {\n                _didIteratorError2 = true;\n                _iteratorError2 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion2 && _iterator2.return) {\n                        _iterator2.return();\n                    }\n                } finally {\n                    if (_didIteratorError2) {\n                        throw _iteratorError2;\n                    }\n                }\n            }\n\n            this.enemy = new _generic_enemy2.default({\n                game: game,\n                x: 6 * 16,\n                y: 0,\n                family: \"humanoid\",\n                id: \"4-2\"\n            });\n            this.enemy.body.strength = 1000;\n\n            /*this.enemy2 = new GenericEnemy({\n                game,\n                x: 9*16,\n                y: 4*16,\n                family: \"humanoid\",\n                id: \"5-6\"\n            });\n            this.enemy2.body.strength = 0;*/\n\n            game.hero = game.add.sprite(320, 25 + 8, 'sprites');\n            game.hero.animations.add(\"down\", [\"hero/hero-down-0\", \"hero/hero-down-1\"], 5, true);\n            game.hero.animations.add(\"right\", [\"hero/hero-right-0\", \"hero/hero-right-1\"], 5, true);\n            game.hero.animations.add(\"left\", [\"hero/hero-left-0\", \"hero/hero-left-1\"], 5, true);\n            game.hero.animations.add(\"up\", [\"hero/hero-up-0\", \"hero/hero-up-1\"], 5, true);\n            game.hero.animations.add(\"hit-down\", [\"hero/hero-hit-down-0\", \"hero/hero-hit-down-1\", \"hero/hero-hit-down-2\", \"hero/hero-hit-down-3\"], 15, false);\n            game.hero.animations.add(\"hit-right\", [\"hero/hero-hit-right-0\", \"hero/hero-hit-right-1\", \"hero/hero-hit-right-2\", \"hero/hero-hit-right-3\"], 15, false);\n            game.hero.animations.add(\"hit-left\", [\"hero/hero-hit-left-0\", \"hero/hero-hit-left-1\", \"hero/hero-hit-left-2\", \"hero/hero-hit-left-3\"], 15, false);\n            game.hero.animations.add(\"hit-up\", [\"hero/hero-hit-up-0\", \"hero/hero-hit-up-1\", \"hero/hero-hit-up-2\", \"hero/hero-hit-up-3\"], 15, false);\n            game.hero.play(\"down\");\n            game.physics.gridPhysics.enable(game.hero);\n            game.hero.body.player = true;\n            game.hero.body.baseVelocity = 75;\n            game.hero.body.strength = 10;\n            game.hero.body.maxCue = 10;\n            game.hero.debugger = false;\n            game.hero.body.collideWorldBounds = true;\n            game.hero.body.immovable = true;\n\n            game.marker = game.add.sprite(0, 0, 'sprites');\n            game.marker.animations.add(\"blink\", [\"marker/blink1\", \"marker/blink2\"], 5, true);\n            game.marker.play(\"blink\");\n\n            this.cursors = game.input.keyboard.createCursorKeys();\n            this.renderGrid = false;\n            if (!this.debugGUI) {\n                this.debugGUI = new _debugGUI2.default();\n            }\n            this.debugGUI.setupGUI(this);\n            game.input.mouse.capture = true;\n            this.physics.addToQue(this.enemy);\n            //  this.physics.addToQue(this.enemy2);\n\n            this.physics.addToQue(game.hero);\n            this.physics.nextTurn();\n            game.hero.body.turnSteps = game.hero.body.activeSteps + 1;\n        }\n    }, {\n        key: 'update',\n        value: function update() {\n            var game = this.game;\n            var hero = this.game.hero;\n\n            if (!hero.body.myTurn && hero.body.physics.turnbased) {\n                return;\n            }\n            game.hero.body.setVelocity(0, 0);\n\n            if (hero.body.activeSteps >= hero.body.turnSteps) {\n                hero.body.turnSteps = hero.body.activeSteps + 1;\n\n                this.physics.nextTurn(hero.body);\n            }\n\n            game.marker.x = 8 * Math.round(game.input.activePointer.x / 8);\n            game.marker.y = 8 * Math.round(game.input.activePointer.y / 8);\n\n            var anim = \"\";\n            switch (hero.body.facing) {\n                case Phaser.UP:\n                    anim = \"up\";\n                    break;\n                case Phaser.RIGHT:\n                    anim = \"right\";\n                    break;\n                case Phaser.DOWN:\n                    anim = \"down\";\n                    break;\n                case Phaser.LEFT:\n                    anim = \"left\";\n                    break;\n            }\n\n            if (hero.body.struggling) {\n                anim = \"hit-\" + anim;\n            }\n\n            hero.play(anim);\n            if (!hero.body.struggling && !hero.body.isMoving.any) {\n                hero.animations.stop();\n            }\n\n            var vel = game.hero.body.baseVelocity;\n\n            if (game.input.activePointer.isDown) {\n                hero.body.moveToPixelXY(game.input.activePointer.x, game.input.activePointer.y, vel);\n            }\n\n            if (game.input.keyboard.isDown(Phaser.Keyboard.LEFT)) {\n                game.hero.body.setVelocity(-vel, 0);\n            } else if (game.input.keyboard.isDown(Phaser.Keyboard.RIGHT)) {\n                game.hero.body.setVelocity(vel, 0);\n            }\n            if (game.input.keyboard.isDown(Phaser.Keyboard.UP)) {\n                game.hero.body.setVelocity(0, -vel);\n            } else if (game.input.keyboard.isDown(Phaser.Keyboard.DOWN)) {\n                game.hero.body.setVelocity(0, vel);\n            }\n        }\n    }, {\n        key: 'render',\n        value: function render() {\n            if (this.game.hero.debugger) {\n                this.game.hero.body.renderDebugBody();\n            }\n        }\n    }]);\n\n    return GameState;\n}(Phaser.State);\n\nexports.default = GameState;\n"]}