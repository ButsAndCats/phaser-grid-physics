{"version":3,"sources":["app/plugin/gridPhysics/gridBody.js","app/plugin/gridPhysics/gridDebug.js","app/plugin/gridPhysics/gridPhysics.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA/8BA;AAAA;ACAA;AAAA;AACA;AACA;AAFA;AAAA;ACAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAngBA;AAAA","file":"dist/gridPhysics.js","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/*jshint esversion: 6 */\n\nvar gridBody = function () {\n    function gridBody(sprite) {\n        _classCallCheck(this, gridBody);\n\n        /**\n         * @property {Phaser.Sprite} sprite - Reference to the parent Sprite.\n         */\n        this.sprite = sprite;\n\n        /**\n         * @property {Phaser.Game} game - Local reference to game.\n         */\n        this.game = sprite.game;\n\n        /**\n         * @property {Phaser.Game} game - Local reference to general grid physics properties.\n         */\n        this.physics = this.game.physics.gridPhysics;\n\n        // UNDECIDED:\n        /**\n         * @property {boolean} enable - A disabled body won't be checked for any form of collision or overlap or have its pre/post updates run.\n         * @default\n         */\n        //this.enable = true;\n\n        // TODO:\n        /**\n         * @property {Phaser.Point} offset - The offset of the Physics Body from the Sprite x/y this.gridPosition.\n         */\n        //  this.offset = new Phaser.Point();\n\n\n        /**\n         * @property {Phaser.Point} position - The position of the physics body.\n         * @readonly\n         */\n        this.gridPosition = new Phaser.Point(0, 0);\n\n        /**\n         * @property {number} width - The calculated width of the physics body in grid units. Default match sprite size.\n         * @readonly\n         */\n        this.width = Math.round(sprite.width / this.physics.gridSize.x);\n\n        /**\n         * @property {number} height - The calculated height of the physics body in grid units. Default match sprite size.\n         * @readonly\n         */\n        this.height = Math.round(sprite.height / this.physics.gridSize.y);\n\n        /**\n         * @property {Phaser.Point} velocity - The velocity, or rate of change in speed of the Body. Measured in pixels per second.\n         */\n        this.velocity = new Phaser.Point();\n\n        /**\n         * @property {Phaser.Point} _desiredVelocity - Velocity the entity strives to get.\n         * @readonly\n         */\n        this._desiredVelocity = new Phaser.Point();\n\n        // TODO:\n        /**\n         * @property {Phaser.Point} _forcedVelocity - Velocity the entity is being pushed or otherwise forced.\n         * @readonly\n         */\n        //this._forcedVelocity = new Phaser.Point();\n\n        // TODO:\n        /**\n         * A Signal that is dispatched when this Body collides with another Body.\n         */\n        //this.onCollide = null;\n\n        /**\n         * @property {number} mass - The mass of the body. A body with strength => this.mass will be able to push this body.\n         * @default\n         */\n        this.mass = 1;\n\n        /**\n         * @property {number} strength - Total mass that this body can move. -1 = unlimited\n         * @default\n         */\n        this.strength = -1;\n\n        /**\n         * @property {number} pushLimit - Max number of objects that can be pushed, -1 = unlimited\n         * @default\n         */\n        this.pushLimit = -1;\n\n        /**\n         * @property {number} struggle - Speed decrese ( velocity /= struggle * pushed mass), 0 = no decrese\n         * NOTE: This will probably change to allow more flexible calculations (strugglePower = struggle.c + struggle.k * mass).\n         * @default\n         */\n        this.struggle = 0;\n\n        /**\n         * @property {boolean} struggling - If the object is trying to move but not able, it will struggle :-)\n         * @readonly\n         */\n        this.struggling = false;\n\n        /**\n         * @property {number} facing - A const reference to the direction the Body is traveling or facing.\n         * @default\n         */\n        this.facing = Phaser.NONE;\n\n        /**\n         * @property {boolean} immovable - An immovable Body will not receive any impacts from other bodies.\n         * @default\n         */\n        this.immovable = false;\n\n        /**\n         * @property {boolean} collidable - The body will check collision only if collidible is set to true.\n         * @default\n         */\n        this.collidable = true;\n\n        /**\n         * A Body can be set to collide against the World bounds automatically and rebound back into the World if this is set to true. Otherwise it will leave the World.\n         * @property {boolean} collideWorldBounds - Should the Body collide with the World bounds?\n         */\n        this.collideWorldBounds = false;\n\n        /**\n         * @property {object} isMoving - Is populated with information if the body is actually moving.\n         * @readonly\n         */\n        this.isMoving = {\n            x: false,\n            y: false,\n            any: false\n        };\n\n        // MAYBE:\n        /**\n         * @property {Phaser.Signal} onMoveComplete - Listen for the completion of `moveTo` or `moveFrom` events.\n         */\n        //this.onMoveComplete = new Phaser.Signal();\n\n\n        this.moveTo = {\n            active: false,\n            path: [],\n            next: null,\n            recalc: 0 // 0 - never, 1 - if collision, 2 - each step (not impleneted yet)\n        };\n\n        this.magnetism = {\n            dragItself: false, // If the body's weight is less than the object it's trying to pull and it's movable=true it will be pulled to the object instead of the opposite\n            weakenByFactor: 1, //A power of 10 with weakenByFactor of 0.5 will have a power of 10*0.5 = 5 on one gridunit distance, and 10*0.5*0.5 = 2.5 on two.\n            maxRange: 1, // Stop magnetism after this amount of squares regardless of power or weakenByFactor\n            top: {\n                active: false,\n                power: 0, // 0 = Infinited, If dragged this magnetism could pull this mass without break seal.\n                pole: null, // any pole-id (could be NORTH/SOUTH), null == any\n                attractedTo: null, // any pole-id of other body\n                attractedToAll: false },\n            right: {\n                active: false,\n                power: 0,\n                pole: null,\n                attractedTo: null,\n                attractedToAll: false\n            },\n            bottom: {\n                active: false,\n                power: 0,\n                pole: null,\n                attractedTo: null,\n                attractedToAll: false\n            },\n            left: {\n                active: false,\n                power: 0,\n                pole: null,\n                attractedTo: null,\n                attractedToAll: false\n            }\n        };\n\n        this.cojoinedBodies = []; // Array of bodies\n\n\n        /**\n         * @property {Phaser.Point} shadow - The shadow reserves tiles this object moves from while animating a move to prevent overlaps from other sprites.\n         * NOTE: Not yet entirely implemented\n         * @readonly\n         */\n        this._shadow = new Phaser.Point(0, 0);\n\n        /**\n         * @property {object} isLocked - Used to prevent body from doing new moves before the last is finished.\n         * NOTE: Not yet entirely implemented: May allow to turn in same direction and other stuff to make responsive.\n         * @readonly\n         */\n        this.isLocked = {\n            x: false,\n            y: false,\n            any: false\n        };\n\n        // MAY BE REMOVED:\n        this._longPress = 0; // 0 - X, 1-Y (längsta nedtryckt)\n\n\n        /**\n         * @property {Number} activeSteps - Number of steps the body has taken.\n         * NOTE: Not yet entirely implemented\n         * @readonly\n         */\n        this.activeSteps = 0;\n\n        /**\n         * @property {Number} passiveSteps - Number of steps the body has been forced to take (being pushed).\n         * NOTE: Not yet entirely implemented\n         * @readonly\n         */\n        this.passiveSteps = 0;\n\n        this.myTurn = false;\n        this.turns = 0;\n        this.reload = 1;\n\n        this.snapToGrid();\n    }\n\n    _createClass(gridBody, [{\n        key: \"snapToGrid\",\n        value: function snapToGrid() {\n            this.gridPosition = {\n                x: Math.round(this.sprite.x / this.physics.gridSize.x),\n                y: Math.round(this.sprite.y / this.physics.gridSize.y)\n            };\n            this.sprite.x = this.physics.gridSize.x * this.gridPosition.x;\n            this.sprite.y = this.physics.gridSize.y * this.gridPosition.y;\n        }\n    }, {\n        key: \"collideTilemap\",\n        value: function collideTilemap(dx, dy) {\n            var slide = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n            var position = {\n                x: this.gridPosition.x + dx,\n                y: this.gridPosition.y + dy\n            };\n            var width = this.width;\n            var height = this.height;\n            if (dx !== 0) {\n                width = 1;\n                if (dx > 0) {\n                    position.x += this.width - 1;\n                }\n            } else {\n                if (dy !== 0) {\n                    height = 1;\n                    if (dy > 0) {\n                        position.y += this.height - 1;\n                    }\n                }\n            }\n            var tileRatio = {\n                x: 2,\n                y: 2\n            };\n\n            for (var x = position.x; x < position.x + width; x++) {\n                for (var y = position.y; y < position.y + height; y++) {\n                    var collide = false;\n                    var _iteratorNormalCompletion = true;\n                    var _didIteratorError = false;\n                    var _iteratorError = undefined;\n\n                    try {\n                        for (var _iterator = this.physics.tilemaplayers[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                            var layer = _step.value;\n\n                            var tile = this.game.map.getTile(Math.floor(x * this.physics.gridSize.x / layer.collisionWidth), Math.floor(y * this.physics.gridSize.y / layer.collisionHeight), layer, true);\n\n                            if (!tile && this.collideWorldBounds) {\n                                // No tile? Outside of worldBounds!\n                                collide = true;\n                                break;\n                            } else if (!tile || tile.index === -1) {\n                                // No tile, or empty - OK\n                                continue;\n                            }\n\n                            if (tile.collideRight && tile.collideLeft && tile.collideDown && tile.collideUp) {\n                                // tile collides whatever direction the body enter\n                                collide = true;\n                                break;\n                            } else if (dx < 0 && tile.collideRight) {\n                                // moving left and the tile collides from the right\n                                collide = true;\n                                break;\n                            } else if (dx > 0 && tile.collideLeft) {\n                                collide = true;\n                                break;\n                            }\n                            if (dy < 0 && tile.collideDown) {\n                                collide = true;\n                                break;\n                            } else if (dy > 0 && tile.collideUp) {\n                                collide = true;\n                                break;\n                            }\n\n                            // Prevents bodies to walk with path of body outside of blocked tile side\n                            if (dx != 0) {\n                                if (tile.borderUp && position.y < tile.y * tileRatio.y) {\n                                    collide = true;\n                                    break;\n                                } else if (tile.borderDown && position.y + height > tile.y * tileRatio.y) {\n                                    collide = true;\n                                    break;\n                                }\n                            }\n                            if (dy != 0) {\n                                if (tile.borderLeft && position.x < tile.x * tileRatio.x) {\n                                    collide = true;\n                                    break;\n                                } else if (tile.borderRight && position.x + width > tile.x * tileRatio.x) {\n                                    collide = true;\n                                    break;\n                                }\n                            }\n                        }\n                    } catch (err) {\n                        _didIteratorError = true;\n                        _iteratorError = err;\n                    } finally {\n                        try {\n                            if (!_iteratorNormalCompletion && _iterator.return) {\n                                _iterator.return();\n                            }\n                        } finally {\n                            if (_didIteratorError) {\n                                throw _iteratorError;\n                            }\n                        }\n                    }\n\n                    if (collide) {\n                        if (slide) {\n                            // Left-over from previous working version, needs review...\n                            if (dx !== 0) {\n                                if (!this.collideTilemap(dx, dy - 1)) {\n                                    return {\n                                        dx: dx,\n                                        dy: dy - 1\n                                    };\n                                } else if (!this.collideTilemap(dx, dy + 1)) {\n                                    return {\n                                        dx: dx,\n                                        dy: dy + 1\n                                    };\n                                }\n                            }\n                            if (dy !== 0) {\n                                if (!this.collideTilemap(dx - 1, dy)) {\n                                    return {\n                                        dx: dx - 1,\n                                        dy: dy\n                                    };\n                                } else if (!this.collideTilemap(dx + 1, dy)) {\n                                    return {\n                                        dx: dx + 1,\n                                        dy: dy\n                                    };\n                                }\n                            }\n                        }\n                        return {\n                            dx: 0,\n                            dy: 0\n                        };\n                    }\n                }\n            }\n            return false;\n        }\n    }, {\n        key: \"setVelocity\",\n        value: function setVelocity(x) {\n            var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n            // longpress is not yet implemented\n            y = y !== null ? y : x;\n\n            if (x === 0 && y !== 0) {\n                this._longpress = 1;\n            } else if (y === 0 && x !== 0) {\n                this._longpress = 0;\n            }\n            this._desiredVelocity = {\n                x: x,\n                y: y\n            };\n        }\n    }, {\n        key: \"_intersectRect\",\n        value: function _intersectRect(r1, r2) {\n            return !(r2.x >= r1.x + r1.width || r2.x + r2.width <= r1.x || r2.y >= r1.y + r1.height || r2.y + r2.height <= r1.y);\n        }\n    }, {\n        key: \"preUpdate\",\n        value: function preUpdate() {\n            // Required on bodies by Phaser\n        }\n    }, {\n        key: \"testMove\",\n        value: function testMove(dx, dy) {\n            if (!this.collidable) {\n                return true;\n            }\n            if (this.collideTilemap(dx, dy)) {\n                return false;\n            }\n            // Kolla först tilemap för det kan bli krock direkt!\n            var _iteratorNormalCompletion2 = true;\n            var _didIteratorError2 = false;\n            var _iteratorError2 = undefined;\n\n            try {\n                for (var _iterator2 = this.physics.bodies[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n                    var body = _step2.value;\n\n\n                    if (this !== body && body.collidable) {\n                        // Kolla om kollision\n                        if (this._intersectRect({\n                            x: this.gridPosition.x + dx,\n                            y: this.gridPosition.y + dy,\n                            width: this.width,\n                            height: this.height\n                        }, {\n                            x: body.gridPosition.x,\n                            y: body.gridPosition.y,\n                            width: body.width,\n                            height: body.height\n                        })) {\n                            // Om det krockar och oflyttbar, ta bort ur pushchain\n                            if (body.immovable) {\n                                return false;\n                            } else {\n                                if (this.physics._pushChain.indexOf(body) === -1) {\n                                    this.physics._pushChain.push(body); // Tryck på denna\n                                    if (!body.testMove(dx, dy)) {\n                                        // kolla upp kroppen\n                                        return false;\n                                    };\n                                }\n                            }\n                        }\n                    }\n                }\n            } catch (err) {\n                _didIteratorError2 = true;\n                _iteratorError2 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion2 && _iterator2.return) {\n                        _iterator2.return();\n                    }\n                } finally {\n                    if (_didIteratorError2) {\n                        throw _iteratorError2;\n                    }\n                }\n            }\n\n            return true;\n        }\n    }, {\n        key: \"postUpdate\",\n        value: function postUpdate() {\n            if (this.isLocked.x || this.isLocked.y) {\n                return;\n            }\n\n            if (this.moveTo.active) {\n                this._desiredVelocity = {\n                    x: 0,\n                    y: 0\n                };\n                var dest = this.moveTo.path[this.moveTo.next];\n                if (dest.x < this.gridPosition.x) {\n                    this._desiredVelocity.x = -100;\n                } else if (dest.x > this.gridPosition.x) {\n                    this._desiredVelocity.x = 100;\n                } else if (dest.y < this.gridPosition.y) {\n                    this._desiredVelocity.y = -100;\n                } else if (dest.y > this.gridPosition.y) {\n                    this._desiredVelocity.y = 100;\n                }\n                this.moveTo.next++;\n                if (this.moveTo.next > this.moveTo.path.length - 1) {\n                    this.moveTo.active = false;\n                }\n            }\n\n            this.isMoving = {\n                x: false,\n                y: false,\n                any: false\n            };\n\n            if (this._desiredVelocity.x === 0 && this._desiredVelocity.y === 0) {\n                this.velocity.x = 0;\n                this.velocity.y = 0;\n                this.struggling = false;\n                return;\n            }\n\n            this.physics._pushChain = [];\n            var moveOk = true;\n            var _d = {};\n            var _arr = [\"x\", \"y\"];\n            for (var _i = 0; _i < _arr.length; _i++) {\n                var dim = _arr[_i];\n                _d[dim] = this._desiredVelocity[dim] === 0 ? 0 : this._desiredVelocity[dim] > 0 ? 1 : -1;\n            }\n\n            var _arr2 = [0, 1];\n            for (var _i2 = 0; _i2 < _arr2.length; _i2++) {\n                var _dim = _arr2[_i2]; // Array här ändrar ordning efter prio\n                if (_dim === 0) {\n                    if (_d.x === 0) {\n                        continue;\n                    }\n                    if (!this.testMove(_d.x, 0)) {\n                        moveOk = false;\n                        break;\n                    } else {\n                        moveOk = true;\n                    }\n                } else {\n                    if (_d.y === 0) {\n                        continue;\n                    }\n                    if (!this.testMove(0, _d.y)) {\n                        moveOk = false;\n                        break;\n                    } else {\n                        moveOk = true;\n                    }\n                }\n            }\n\n            // Check is strong enough\n            if (this.strength > -1 || this.struggle > 1) {\n                var totalMass = 0;\n                var _iteratorNormalCompletion3 = true;\n                var _didIteratorError3 = false;\n                var _iteratorError3 = undefined;\n\n                try {\n                    for (var _iterator3 = this.physics._pushChain[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n                        var body = _step3.value;\n\n                        totalMass += body.mass;\n                    }\n                } catch (err) {\n                    _didIteratorError3 = true;\n                    _iteratorError3 = err;\n                } finally {\n                    try {\n                        if (!_iteratorNormalCompletion3 && _iterator3.return) {\n                            _iterator3.return();\n                        }\n                    } finally {\n                        if (_didIteratorError3) {\n                            throw _iteratorError3;\n                        }\n                    }\n                }\n\n                if (this.strength > -1 && totalMass > this.strength) {\n                    moveOk = false;\n                }\n                if (this.struggle > 1 && totalMass > 0) {\n                    this._desiredVelocity.x = this._desiredVelocity.x / (totalMass * this.struggle);\n                    this._desiredVelocity.y = this._desiredVelocity.y / (totalMass * this.struggle);\n                }\n            }\n            if (this.pushLimit > -1 && this.physics._pushChain.length > this.pushLimit) {\n                moveOk = false;\n            }\n\n            if (!moveOk) {\n                if (this._desiredVelocity.x !== 0 || this._desiredVelocity.y !== 0) {\n                    this.struggling = true;\n                }\n                if (this._desiredVelocity.x > 0) {\n                    this.facing = Phaser.RIGHT;\n                } else if (this._desiredVelocity.x < 0) {\n                    this.facing = Phaser.LEFT;\n                } else if (this._desiredVelocity.y < 0) {\n                    this.facing = Phaser.UP;\n                } else if (this._desiredVelocity.y > 0) {\n                    this.facing = Phaser.DOWN;\n                }\n                this.velocity.x = 0;\n                this.velocity.y = 0;\n                this._shadow.x = 0;\n                this._shadow.y = 0;\n\n                return;\n            }\n\n            var _arr3 = [\"x\", \"y\"];\n            for (var _i3 = 0; _i3 < _arr3.length; _i3++) {\n                var _dim2 = _arr3[_i3];\n                this.velocity[_dim2] = this._desiredVelocity[_dim2];\n                this._shadow[_dim2] = 0;\n                if (this.velocity[_dim2] != 0) {\n                    this.gridPosition[_dim2] += this.velocity[_dim2] > 0 ? 1 : -1;\n                    this.isLocked[_dim2] = true;\n                    this._shadow[_dim2] = this.velocity[_dim2] < 0 ? 1 : -1;\n\n                    var _iteratorNormalCompletion4 = true;\n                    var _didIteratorError4 = false;\n                    var _iteratorError4 = undefined;\n\n                    try {\n                        for (var _iterator4 = this.physics._pushChain[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n                            var _body = _step4.value;\n\n                            _body.passiveSteps++;\n                            _body.snapToGrid();\n                            _body.velocity[_dim2] = this._desiredVelocity[_dim2];\n                            _body.gridPosition[_dim2] += _body.velocity[_dim2] > 0 ? 1 : -1;\n                            _body.isLocked[_dim2] = true;\n                        }\n                    } catch (err) {\n                        _didIteratorError4 = true;\n                        _iteratorError4 = err;\n                    } finally {\n                        try {\n                            if (!_iteratorNormalCompletion4 && _iterator4.return) {\n                                _iterator4.return();\n                            }\n                        } finally {\n                            if (_didIteratorError4) {\n                                throw _iteratorError4;\n                            }\n                        }\n                    }\n                }\n            }\n\n            if (this.velocity.x > 0) {\n                this.facing = Phaser.RIGHT;\n            } else if (this.velocity.x < 0) {\n                this.facing = Phaser.LEFT;\n            } else if (this.velocity.y < 0) {\n                this.facing = Phaser.UP;\n            } else if (this.velocity.y > 0) {\n                this.facing = Phaser.DOWN;\n            }\n\n            if (this.velocity.x !== 0) {\n                this.isMoving.x = true;\n            }\n            if (this.velocity.y !== 0) {\n                this.isMoving.y = true;\n            }\n            this.isMoving.any = true;\n            this.struggling = false;\n\n            this.baseVelocity = 75;\n            this.activeSteps++;\n        }\n    }, {\n        key: \"renderDebugBody\",\n        value: function renderDebugBody() {\n            if (!this.debugBody) {\n                this.debugBody = new Phaser.Rectangle(sprite.x, sprite.y, sprite.width, sprite.height);\n                this.debugShadow = new Phaser.Rectangle(sprite.x, sprite.y, sprite.width, sprite.height);\n            }\n\n            this.debugBody.x = this.gridPosition.x * this.physics.gridSize.x;\n            this.debugBody.y = this.gridPosition.y * this.physics.gridSize.y;\n            this.debugShadow.x = this.gridPosition.x * this.physics.gridSize.x + this.physics.gridSize.x * this._shadow.x;\n            this.debugShadow.y = this.gridPosition.y * this.physics.gridSize.y + this.physics.gridSize.y * this._shadow.y;\n            if (this._shadow.x == 0) {\n                this.debugShadow.width = this.sprite.width;\n                this.debugShadow.height = this.physics.gridSize.y;\n            } else {\n                this.debugShadow.width = this.physics.gridSize.x;\n                this.debugShadow.height = this.sprite.height;\n            }\n            game.debug.geom(this.debugBody, 'rgba(0,255,0,0.4)');\n        }\n    }, {\n        key: \"renderBodyInfo\",\n        value: function renderBodyInfo(debug, body) {\n            debug.line('x: ' + body.gridPosition.x, 'y: ' + body.gridPosition.y, 'width: ' + body.width, 'height: ' + body.height);\n            /*debug.line('x: ' + body.x.toFixed(2), 'y: ' + body.y.toFixed(2), 'width: ' + body.width, 'height: ' + body.height);\n            debug.line('velocity x: ' + body.velocity.x.toFixed(2), 'y: ' + body.velocity.y.toFixed(2), 'deltaX: ' + body._dx.toFixed(2), 'deltaY: ' + body._dy.toFixed(2));\n            debug.line('acceleration x: ' + body.acceleration.x.toFixed(2), 'y: ' + body.acceleration.y.toFixed(2), 'speed: ' + body.speed.toFixed(2), 'angle: ' + body.angle.toFixed(2));\n            debug.line('gravity x: ' + body.gravity.x, 'y: ' + body.gravity.y, 'bounce x: ' + body.bounce.x.toFixed(2), 'y: ' + body.bounce.y.toFixed(2));\n            debug.line('touching left: ' + body.touching.left, 'right: ' + body.touching.right, 'up: ' + body.touching.up, 'down: ' + body.touching.down);\n            debug.line('blocked left: ' + body.blocked.left, 'right: ' + body.blocked.right, 'up: ' + body.blocked.up, 'down: ' + body.blocked.down);*/\n        }\n    }, {\n        key: \"moveToPixelXY\",\n        value: function moveToPixelXY(x, y) {\n            var speed = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 60;\n            var maxTime = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n            var active = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n\n            x = Math.round(x / this.physics.gridSize.x);\n            y = Math.round(y / this.physics.gridSize.y);\n            this.moveToXY(x, y, speed, maxTime, active);\n        }\n    }, {\n        key: \"moveToXY\",\n        value: function moveToXY(x, y) {\n            var speed = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 60;\n\n            var _this = this;\n\n            var maxTime = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n            var active = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n\n            /*\n              Yes, I know that this is ridiculously inefficient rebuilding the grid from the tilemap\n              on each call without any cache, and trying to find the path of the full current map\n              even if it's not necessarily in most cases.\n               It's also still buggy. Different bodysizes and stuff is a challenge, and now\n              the body size is locked to 2x2 of the grid size.\n               And, also it just checks the first tilemap layer for collision even if you added more.\n             */\n\n            if (typeof EasyStar === 'undefined') {\n                console.error(\"Grid Physics error: Easystar.js must be enabled!\");\n                return;\n            }\n            if (this.physics.render.path || this.physics.render.pathCollision) {\n                this.physics.resetDebugRenderer();\n            }\n\n            var easystar = new EasyStar.js();\n\n            // Generate array\n            // Respond\n            var grid = [];\n            var i = 0;\n            var tileRatio = {\n                x: this.physics.tilemaplayers[0].layer.data[0][0].width / game.physics.gridPhysics.gridSize.x,\n                y: this.physics.tilemaplayers[0].layer.data[0][0].height / game.physics.gridPhysics.gridSize.y\n            };\n            var _iteratorNormalCompletion5 = true;\n            var _didIteratorError5 = false;\n            var _iteratorError5 = undefined;\n\n            try {\n                for (var _iterator5 = this.physics.tilemaplayers[0].layer.data[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n                    var row = _step5.value;\n\n                    grid[i] = [];\n                    grid[i + 1] = [];\n                    var _iteratorNormalCompletion7 = true;\n                    var _didIteratorError7 = false;\n                    var _iteratorError7 = undefined;\n\n                    try {\n                        for (var _iterator7 = row[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {\n                            var _tile = _step7.value;\n\n                            if (_tile.collideUp && _tile.collideDown && _tile.collideLeft && _tile.collideRight) {\n                                // ¦¦ --> && när conditional\n                                for (var dy = 0; dy < tileRatio.y; dy++) {\n                                    for (var dx = 0; dx < tileRatio.x; dx++) {\n                                        grid[i + dx].push(1);\n                                    }\n                                }\n                            } else if (_tile.collideUp || _tile.collideDown || _tile.collideLeft || _tile.collideRight) {\n                                for (var _dy = 0; _dy < tileRatio.y; _dy++) {\n                                    for (var _dx = 0; _dx < tileRatio.x; _dx++) {\n                                        grid[i + _dx].push(4);\n                                    }\n                                }\n                            } else {\n                                for (var _dy2 = 0; _dy2 < tileRatio.y; _dy2++) {\n                                    for (var _dx2 = 0; _dx2 < tileRatio.x; _dx2++) {\n                                        grid[i + _dx2].push(0);\n                                    }\n                                }\n                            }\n                        }\n                        //i++;\n                    } catch (err) {\n                        _didIteratorError7 = true;\n                        _iteratorError7 = err;\n                    } finally {\n                        try {\n                            if (!_iteratorNormalCompletion7 && _iterator7.return) {\n                                _iterator7.return();\n                            }\n                        } finally {\n                            if (_didIteratorError7) {\n                                throw _iteratorError7;\n                            }\n                        }\n                    }\n\n                    i += tileRatio.y;\n                }\n\n                // Bodies\n            } catch (err) {\n                _didIteratorError5 = true;\n                _iteratorError5 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion5 && _iterator5.return) {\n                        _iterator5.return();\n                    }\n                } finally {\n                    if (_didIteratorError5) {\n                        throw _iteratorError5;\n                    }\n                }\n            }\n\n            var _iteratorNormalCompletion6 = true;\n            var _didIteratorError6 = false;\n            var _iteratorError6 = undefined;\n\n            try {\n                for (var _iterator6 = this.physics.bodies[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n                    var body = _step6.value;\n\n                    if (body === this) {\n                        continue;\n                    }\n                    for (var _x11 = 0; _x11 < body.width; _x11++) {\n                        for (var _y3 = 0; _y3 < body.height; _y3++) {\n                            grid[body.gridPosition.y + _y3][body.gridPosition.x + _x11] = 3;\n                        }\n                    }\n                }\n\n                // Smalare korridorer\n            } catch (err) {\n                _didIteratorError6 = true;\n                _iteratorError6 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion6 && _iterator6.return) {\n                        _iterator6.return();\n                    }\n                } finally {\n                    if (_didIteratorError6) {\n                        throw _iteratorError6;\n                    }\n                }\n            }\n\n            for (var _y = 0; _y < grid.length; _y++) {\n\n                for (var _x9 = 0; _x9 < grid[0].length; _x9++) {\n                    if (_x9 > 0 && grid[_y][_x9] > 0 && grid[_y][_x9] < 4) {\n                        if (grid[_y][_x9 - 1] == 0 || grid[_y][_x9 - 1] == 4) {\n                            grid[_y][_x9 - 1] = 2;\n                        }\n                        if (_y > 0 && grid[_y - 1][_x9] == 0 || grid[_y][_x9 - 1] == 4) {\n                            grid[_y - 1][_x9] = 2;\n                        }\n                        if (_x9 > 0 && _y > 0 && grid[_y - 1][_x9 - 1] == 0 || grid[_y][_x9 - 1] == 4) {\n                            grid[_y - 1][_x9 - 1] = 2;\n                        }\n                    }\n                }\n            }\n\n            //debugger;\n            //        console.warn(grid);\n\n            this.physics.renderPathCollision(grid);\n\n            easystar.setGrid(grid);\n\n            // Directional condition\n            for (var _y2 = 0; _y2 < grid.length; _y2++) {\n                for (var _x10 = 0; _x10 < grid[0].length; _x10++) {\n\n                    if (grid[_y2][_x10] === 4) {\n                        var tile = this.physics.tilemaplayers[0].layer.data[Math.round(_y2 / 2)][Math.round(_x10 / 2)];\n                        var paths = []; //;\n                        if (!tile.collideUp) {\n                            paths.push(EasyStar.BOTTOM);\n                        }\n                        if (!tile.collideRight) {\n                            paths.push(EasyStar.LEFT);\n                        }\n                        if (!tile.collideDown) {\n                            paths.push(EasyStar.TOP);\n                        }\n                        if (!tile.collideLeft) {\n                            paths.push(EasyStar.RIGHT);\n                        }\n                        grid[_y2][_x10] = 0;\n                        easystar.setDirectionalCondition(_x10, _y2, paths);\n                    }\n                }\n            }\n\n            easystar.setAcceptableTiles([0, 4]);\n\n            easystar.findPath(this.gridPosition.x, this.gridPosition.y, x, y, function (path) {\n                if (path === null) {\n                    //console.log(\"Path was not found.\");\n                } else if (path.length > 0) {\n                    //    console.log(\"Path was found. The first Point is \" + path[1].x + \" \" + path[1].y, this);\n                    _this.moveTo = {\n                        active: true,\n                        path: path,\n                        next: 1,\n                        velocity: speed,\n                        recalc: 0\n                    };\n                    _this.physics.renderPath(_this.moveTo.path);\n\n                    /*this.moveTo.x =\n                    this.moveTo.y = path[1].y*2;*/\n                    /*  if (x < this.gridPosition.x) {\n                        //  this.setVelocity(-speed, 0);\n                          this.moveTo.x = -1;\n                      }\n                      else if (x > this.gridPosition.x) {\n                        //  this.setVelocity(speed, 0);\n                          this.moveTo.x = 1;\n                      }\n                      else if (y < this.gridPosition.y) {\n                        //  this.setVelocity(0, -speed);\n                          this.moveTo.y = -1;\n                      } else if (y > this.gridPosition.y) {\n                        //  this.setVelocity(0, speed);\n                          this.moveTo.y = 1;\n                      }*/\n                }\n            });\n            easystar.setIterationsPerCalculation(1000);\n            easystar.calculate();\n\n            // This.isMovingToXY = {active: true, x,y,speed) <-- Kör på automatiskt medan detta finns. Testa ny väg vid varje stopp\n        }\n    }]);\n\n    return gridBody;\n}();\n\nexports.default = gridBody;\n","/** All debug-stuff from Body and Physics will be moved here */\n\"use strict\";\n","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _gridBody = require(\"./gridBody\");\n\nvar _gridBody2 = _interopRequireDefault(_gridBody);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*jshint esversion: 6 */\n\n/**\n * A Sample Plugin demonstrating how to hook into the Phaser plugin system.\n * @class Phaser.Plugin.SamplePlugin\n */\n\n//import GridDebug from './gridDebug';\n\nvar GridPhysics = function (_Phaser$Plugin) {\n    _inherits(GridPhysics, _Phaser$Plugin);\n\n    function GridPhysics(game) {\n        _classCallCheck(this, GridPhysics);\n\n        var _this = _possibleConstructorReturn(this, (GridPhysics.__proto__ || Object.getPrototypeOf(GridPhysics)).call(this, game));\n\n        _this.cnt = 0;\n\n        // Size of Grid in pixels\n        _this.gridSize = new Phaser.Point(8);\n\n        // Shadow size in pixels.\n        _this.shadowSize = 0;\n\n        // Locked while pushed\n        _this.lockBodies = false;\n\n        // Sprites and stuff with gridPhysics enabled\n        _this.bodies = [];\n\n        // Collidable tilemap layers\n        _this.tilemaplayers = [];\n\n        _this.tileGridRatio = new Phaser.Point(-1, -1);\n        console.log(_this.tileGridRatio);\n        _this._pushChain = [];\n\n        _this.map = null;\n\n        //\n        _this.game.physics.gridPhysics = _this;\n\n        _this.debugGfx = {\n            graphics: null,\n            update: true,\n            grid: {\n                active: false,\n                wasActive: false,\n                data: null\n            },\n            path: {\n                active: false,\n                wasActive: false,\n                data: null\n            },\n            pathCollision: {\n                active: false,\n                wasActive: false\n            },\n            collision: {\n                active: false,\n                wasActive: false,\n                data: null\n            }\n        };\n\n        window.debugGfx = _this.debugGfx;\n\n        _this.turnbased = false;\n        _this.turn = 0;\n        _this.que = [];\n\n        return _this;\n    }\n\n    _createClass(GridPhysics, [{\n        key: \"enable\",\n        value: function enable(entity) {\n            switch (entity.type) {\n                case Phaser.SPRITE:\n                    entity.body = new _gridBody2.default(entity);\n                    this.bodies.push(entity.body);\n                    break;\n                case Phaser.TILEMAPLAYER:\n                    this.tilemaplayers.push(entity);\n                    console.log(entity);\n\n                    if (this.tileGridRatio.x === -1) {\n                        this.tileGridRatio.set(entity.collisionWidth / this.gridSize.x, entity.collisionHeight / this.gridSize.y);\n                    }\n\n                    this.addToLayerToCollision(entity);\n                    entity.updateBorders = this.updateBorders.bind(entity);\n                    break;\n                default:\n                    // Phaser.TILEMAP????\n                    if (entity.hasOwnProperty) {\n                        this.map = entity;\n                    }\n                    //            debugger;\n                    break;\n            }\n        }\n    }, {\n        key: \"updateBorders\",\n        value: function updateBorders() {\n            console.log(\"UPDATE BLOCKED\");\n            var data = this.layer.data;\n            for (var y = 0; y < data.length; y++) {\n                console.log(\"y\" + y);\n                for (var x = 0; x < data[y].length; x++) {\n                    var tile = data[y][x];\n                    if (tile.borderUp) {\n                        tile.collideUp = true;\n                        data[y - 1][x].collideDown = true;\n                    }\n                    if (tile.borderDown) {\n                        tile.collideDown = true;\n                        data[y + 1][x].collideUp = true;\n                    }\n                    if (tile.borderLeft) {\n                        tile.collideLeft = true;\n                        data[y][x - 1].collideRight = true;\n                    }\n                    if (tile.borderRight) {\n                        tile.collideRight = true;\n                        data[y][x + 1].collideLeft = true;\n                    }\n                }\n            }\n        }\n    }, {\n        key: \"addToQue\",\n        value: function addToQue(body) {\n            var reload = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n            if (!body.hasOwnProperty(\"myTurn\") && body.hasOwnProperty(\"body\")) {\n                body = body.body;\n            }\n\n            if (reload === 0) {\n                reload = body.reload > 0 ? body.reload : 1;\n            }\n            // Gör kön tillräckligt lång\n            if (this.que.length < reload * 2) {\n                for (var s = 0; s < reload * 2; s++) {\n                    this.que.push(null);\n                }\n            }\n            var pos = reload * 2;\n            while (this.que[pos] != null) {\n                pos++;\n            }\n            this.que.splice(pos, 0, body);\n        }\n    }, {\n        key: \"nextTurn\",\n        value: function nextTurn() {\n            var oldBody = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n            var reload = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n            if (oldBody != null) {\n                oldBody.myTurn = false;\n                oldBody.turns++;\n                this.turn++;\n                this.addToQue(oldBody, reload);\n            }\n\n            var body = null;\n            while (body === null && this.que.length > 0) {\n                body = this.que.shift(0);\n            }\n            if (body === null) {\n                console.error(\"EMPTY QUE!\");\n                return false;\n            }\n            body.myTurn = true;\n        }\n    }, {\n        key: \"update\",\n        value: function update() {\n            this.turnMade = false;\n            var _iteratorNormalCompletion = true;\n            var _didIteratorError = false;\n            var _iteratorError = undefined;\n\n            try {\n                for (var _iterator = this.bodies[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                    var body = _step.value;\n\n                    var next = {\n                        x: body.sprite.x,\n                        y: body.sprite.y\n                    };\n                    var _arr = [\"x\", \"y\"];\n                    for (var _i = 0; _i < _arr.length; _i++) {\n                        var dim = _arr[_i];\n                        if (body.velocity[dim] === 0) {\n                            // Stannat, fixa positionen exakt.\n                            body.sprite[dim] = body.gridPosition[dim] * body.physics.gridSize[dim];\n                            continue;\n                        }\n                        if (body.gridPosition[dim] * body.physics.gridSize[dim] != body.sprite[dim]) {\n                            body.sprite[dim] += body.velocity[dim] * body.game.time.physicsElapsed;\n                            next[dim] = body.sprite[dim] + body.velocity[dim] * body.game.time.physicsElapsed;\n                        }\n                        if (body.velocity[dim] > 0 && next[dim] > body.gridPosition[dim] * body.physics.gridSize[dim]) {\n                            // Nästa steg är klart!\n                            body.isLocked[dim] = false; // Kan sätta ny gridPosition och velocity!\n                        }\n                        if (body.velocity[dim] < 0 && next[dim] < body.gridPosition[dim] * body.physics.gridSize[dim]) {\n                            // Nästa steg är klart!\n                            body.isLocked[dim] = false; // Kan sätta ny gridPosition och velocity!\n                        }\n                        if (!body.isLocked.x && !body.isLocked.y && this.turnbased) {\n                            body.setVelocity(0);\n                        }\n                    }\n                }\n            } catch (err) {\n                _didIteratorError = true;\n                _iteratorError = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion && _iterator.return) {\n                        _iterator.return();\n                    }\n                } finally {\n                    if (_didIteratorError) {\n                        throw _iteratorError;\n                    }\n                }\n            }\n\n            if (this.debugGfx.update) {\n                this.renderDebug();\n            }\n        }\n    }, {\n        key: \"renderDebug\",\n        value: function renderDebug() {\n            var gfx = this.debugGfx;\n            if (gfx.grid.active != gfx.grid.wasActive || gfx.path.active != gfx.path.wasActive || gfx.pathCollision.active != gfx.pathCollision.wasActive || gfx.collision.active != gfx.collision.wasActive) {\n                if (gfx.graphics) {\n                    gfx.graphics.clear();\n                } else {\n                    gfx.graphics = game.add.graphics(0, 0);\n                }\n\n                if (gfx.grid.active) {\n                    this.renderGrid();\n                }\n\n                if (gfx.path.active) {\n                    this.renderPath();\n                }\n\n                if (gfx.pathCollision.active) {\n                    this.renderPathCollision();\n                }\n\n                if (gfx.collision.active) {\n                    this.renderCollision();\n                }\n\n                var _arr2 = ['grid', 'collision', 'path', 'pathCollision'];\n                for (var _i2 = 0; _i2 < _arr2.length; _i2++) {\n                    var type = _arr2[_i2];\n                    gfx[type].wasActive = gfx[type].active;\n                }\n\n                if (gfx.grid.active || gfx.path.active || gfx.pathCollision.active || gfx.collision.active) {\n                    gfx.graphics.alpha = 1;\n                } else {\n                    gfx.graphics.alpha = 0;\n                }\n            }\n        }\n    }, {\n        key: \"renderGrid\",\n        value: function renderGrid() {\n            var graphics = this.debugGfx.graphics;\n            graphics.lineStyle(1, 0x000000, 0.2);\n            for (var x = 0; x < this.game.width / this.gridSize.x; x++) {\n                graphics.moveTo(x * this.gridSize.x, 0);\n                graphics.lineTo(x * this.gridSize.x, this.game.height);\n            }\n            for (var y = 0; y < this.game.height / this.gridSize.y; y++) {\n                graphics.moveTo(0, y * this.gridSize.y);\n                graphics.lineTo(this.game.width, y * this.gridSize.y);\n            }\n        }\n    }, {\n        key: \"renderCollision\",\n        value: function renderCollision() {\n            var graphics = this.debugGfx.graphics;\n            graphics.lineStyle(0, 0x00FF00, 0.0);\n\n            var _iteratorNormalCompletion2 = true;\n            var _didIteratorError2 = false;\n            var _iteratorError2 = undefined;\n\n            try {\n                for (var _iterator2 = this.tilemaplayers[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n                    var layer = _step2.value;\n\n                    for (var y in layer.layer.data) {\n                        for (var x in layer.layer.data[y]) {\n                            var tile = layer.layer.data[y][x];\n                            if (tile.collides) {\n                                graphics.beginFill(0xFF0000, 0.5);\n                                graphics.drawRect(x * tile.width + 1, y * tile.height + 1, tile.width - 2, tile.height - 2);\n                                graphics.endFill();\n                            }\n                        }\n                    }\n                }\n            } catch (err) {\n                _didIteratorError2 = true;\n                _iteratorError2 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion2 && _iterator2.return) {\n                        _iterator2.return();\n                    }\n                } finally {\n                    if (_didIteratorError2) {\n                        throw _iteratorError2;\n                    }\n                }\n            }\n        }\n    }, {\n        key: \"renderPathCollision\",\n        value: function renderPathCollision(data) {\n            if (data) {\n                this.debugGfx.pathCollision.data = data;\n                this.debugGfx.pathCollision.wasActive = false;\n                return;\n            }\n            if (!this.debugGfx.pathCollision.data || this.debugGfx.pathCollision.data.length === 0) {\n                return;\n            }\n\n            var graphics = this.debugGfx.graphics;\n            var grid = this.debugGfx.pathCollision.data;\n\n            for (var y = 0; y < grid.length; y++) {\n                graphics.lineStyle(1, 0xFF0000, 0.3);\n                for (var x = 0; x < grid[0].length; x++) {\n                    if (grid[y][x] != 0) {\n                        if (grid[y][x] < 2) {\n                            graphics.beginFill(0xFF3300, 0.4);\n                        } else if (grid[y][x] == 4) {\n                            graphics.beginFill(0x0000FF, 0.4);\n                        } else {\n                            graphics.beginFill(0xFF33FF, 0.4);\n                        }\n                        graphics.drawRect(x * this.gridSize.x, y * this.gridSize.y, this.gridSize.x, this.gridSize.y);\n                        graphics.endFill();\n                    }\n                }\n            }\n        }\n    }, {\n        key: \"renderPath\",\n        value: function renderPath(data) {\n            if (data) {\n                this.debugGfx.path.data = data;\n                this.debugGfx.path.wasActive = false;\n                return;\n            }\n            if (!this.debugGfx.path.data || this.debugGfx.path.data.length === 0) {\n                return;\n            }\n\n            var graphics = this.debugGfx.graphics;\n            var path = this.debugGfx.path.data;\n            graphics.lineStyle(1, 0x00FF00, 0.5);\n            var _iteratorNormalCompletion3 = true;\n            var _didIteratorError3 = false;\n            var _iteratorError3 = undefined;\n\n            try {\n                for (var _iterator3 = path[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n                    var point = _step3.value;\n\n                    graphics.beginFill(0x00FF00, 0.4);\n\n                    graphics.drawRect(point.x * this.gridSize.x, point.y * this.gridSize.y, this.gridSize.x, this.gridSize.y);\n                }\n            } catch (err) {\n                _didIteratorError3 = true;\n                _iteratorError3 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion3 && _iterator3.return) {\n                        _iterator3.return();\n                    }\n                } finally {\n                    if (_didIteratorError3) {\n                        throw _iteratorError3;\n                    }\n                }\n            }\n\n            var lastPoint = path[path.length - 1];\n            graphics.beginFill(0xFF3300, 0.7);\n\n            graphics.drawRect(lastPoint.x * this.gridSize.x, lastPoint.y * this.gridSize.y, this.gridSize.x, this.gridSize.y);\n            graphics.endFill();\n        }\n    }, {\n        key: \"resetCollisionLayer\",\n        value: function resetCollisionLayer() {\n            var map = this.map;\n            var colLayerIndex = map.getLayerIndex(\"gridPhysicsCollision\");\n            var colTile = void 0,\n                tile = void 0;\n            for (var x = 0; x < map.layers[colLayerIndex].width; x++) {\n                for (var y = 0; y < map.layers[colLayerIndex].height; y++) {\n                    //console.log(collisionLayerName);\n                    map.putTile(1, x, y, \"gridPhysicsCollision\");\n                    colTile = map.getTile(x, y, \"gridPhysicsCollision\");\n                    colTile.collideUp = false;\n                    colTile.collideRight = false;\n                    colTile.collideDown = false;\n                    colTile.collideLeft = false;\n                    //colTile.collides = false;\n                }\n            }\n        }\n    }, {\n        key: \"addToLayerToCollision\",\n        value: function addToLayerToCollision(layer) {\n\n            var map = this.map;\n\n            var colLayerIndex = map.getLayerIndex(\"gridPhysicsCollision\");\n            //let collisionLayer = null;\n            var colTile = void 0,\n                tile = void 0;\n\n            if (!colLayerIndex) {\n                var collisionLayer = map.createBlankLayer(\"gridPhysicsCollision\", map.width, map.height, map.tileWidth, map.tileHeight);\n                colLayerIndex = map.getLayerIndex(\"gridPhysicsCollision\");\n                collisionLayer.visible = false;\n                this.resetCollisionLayer();\n            }\n            // Prepare the collision layer\n\n            // Loop tiles for collision and add to collision layer\n\n            for (var x = 0; x < layer.width; x++) {\n                for (var y = 0; y < layer.height; y++) {\n                    //console.log(x+\"  \"+y)\n                    tile = map.getTile(x, y, layer.index);\n                    if (!tile) {\n                        continue;\n                    }\n                    colTile = map.getTile(x, y, \"gridPhysicsCollision\");\n                    colTile.collideUp = tile.collideUp ? true : colTile.collideUp;\n                    colTile.collideRight = tile.collideRight ? true : colTile.collideRight;\n                    colTile.collideDown = tile.collideDown ? true : colTile.collideDown;\n                    colTile.collideLeft = tile.collideLeft ? true : colTile.collideLeft;\n                    //colTile.collides = tile.collides ? true : colTile.collides;*/\n\n                    console.log(\"TILE\", colTile);\n                }\n            }\n\n            // Set all non-collision tiles to null (save some ram and probably perfomance)\n            /*for (var x = 0; x < map.layers[colLayerIndex].width; x++) {\n                for (var y = 0; y < map.layers[colLayerIndex].height; y++) {\n                    colTile = map.getTile(x, y, collisionLayerName);\n                    if (!colTile.collideUp && !colTile.collideDown && !colTile.collideLeft && !colTile.collideRight) {\n                        map.putTile(null, x, y, collisionLayerName);\n                    }\n                }\n            }*/\n\n            // Build collision grid for pathfinding!\n\n\n            // Fix faces - Not used by GridPhysics ATM, but could be nice for visual debugging\n            map.calculateFaces(colLayerIndex);\n\n            //return collisionLayer ? collisionLayer : null;\n            console.log(map.layers[colLayerIndex]);\n        }\n    }]);\n\n    return GridPhysics;\n}(Phaser.Plugin);\n\nexports.default = GridPhysics;\n"]}